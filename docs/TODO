### TODO 리스트
- 서버 테이블에 좋아요 테이블 2개 작성.
- member 서버 테이블에 private String role; 컬럼 추가.
- 회원 수정할 시, 닉네임 중복 체크 해야한다.



### 변환 작업은 이렇게 한다.
DTO -> Entity 변환 작업은 (Entity Class에서)
Entity -> DTO 변환 작업은 (DTO Class에서)



### Controller -> view 보낼때 이런식으로 보내는데, 이렇게 하는 이유는?
현재 나처럼 return "/members/join"; 이런식으로 보내지 않는다.
e.g.) return userService.getProfileInfo(userId, GetProfileRequestType.UPDATE);
e.g.) return postService.getPostDetail(postId, userId, PostType.BASIC);
e.g.) return postService.getPostDetail(postId, userId, PostType.DEBATE);



### 에러 관련 클래스를 이렇게 작성하는 이유는?
public enum ErrorCode {

    NOT_ISSUED_TOKEN(1000, "파싱에 실패한 토큰입니다."),
    EXPIRED_TOKEN(1001, "유효기간이 만료된 토큰입니다."),
    INVALID_AUTHORIZATION_CODE(1003, "올바르지 않은 authorization code 입니다."),
    INVALID_ACCESS_TOKEN(1004, "잘못된 구글 accessToken 입니다."),
    GOOGLE_SERVER_EXCEPTION(1005, "구글 서버에서 오류가 발생했습니다."),;

    private final int code;
    private final String message;
}

public class MemberException extends CustomException {

    public MemberException(final ErrorCode errorCode) {
        super(errorCode);
    }

    public MemberException(
        final ErrorCode errorCode,
        final Map<String, String> inputValuesByProperty
    ) {
        super(errorCode, inputValuesByProperty);
    }

    public static class NullOrEmptyEmailException extends MemberException {

        public NullOrEmptyEmailException() {
            super(ErrorCode.EMPTY_EMAIL);
        }

        public NullOrEmptyEmailException(final Map<String, String> inputValuesByProperty) {
            super(ErrorCode.EMPTY_EMAIL, inputValuesByProperty);
        }
    }
}


### 서비스단에서의 final 키워드를 붙여주는 이유는?

    public SongSwipeResponse findSongByIdForFirstSwipe(final Long songId, final MemberInfo memberInfo) {
        final Song currentSong = inMemorySongs.getSongById(songId);

        final List<Song> beforeSongs = inMemorySongs.getPrevLikedSongs(currentSong, BEFORE_SONGS_COUNT);
        final List<Song> afterSongs = inMemorySongs.getNextLikedSongs(currentSong, AFTER_SONGS_COUNT);

        return convertToSongSwipeResponse(memberInfo, currentSong, beforeSongs, afterSongs);
    }

    @Transactional
    public Member register(final String email) {
        findByEmail(email).ifPresent(member -> {
            throw new MemberException.ExistMemberException(Map.of("Email", email));
        });

        final Member newMember = new Member(email, BASIC_NICKNAME);
        final Member savedMember = memberRepository.save(newMember);
        savedMember.updateNickname(savedMember.getNickname() + savedMember.getId());
        return savedMember;
    }



### MemberApi 라고 하는데, 이렇게 사용하는 이유는?

    @Tag(name = "Member", description = "회원 관리 API")
    public interface MemberApi {

        @Operation(
            summary = "회원 탈퇴",
            description = "회원 탈퇴로 회원을 삭제한다."
        )
        @ApiResponse(
            responseCode = "204",
            description = "회원 탈퇴, 삭제 성공"
        )
        @Parameter(
            name = "member_id",
            description = "삭제할 회원 id",
            required = true
        )
        @DeleteMapping
        ResponseEntity<Void> deleteMember(
            @PathVariable(name = "member_id") final Long memberId,
            @Authenticated final MemberInfo memberInfo
        );
    }
